# -*- coding: utf-8 -*-
"""Pandas(Series).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wHVz_UnUmYgK5v2gqPM97xqlL4Re-yTp

**PANDAS:**

*   Python library for data analysis and data manipulation.
*   name derived from "Panel Data System".
*   Created by Wes Mckinney

**SERIES:**


*   1-D
*   Homogeneous data
*   Size immutable
*   values are mutable

**Syntax:**

pd.Series(data,index,dtype)

Index is optional, it can be specified if you want to give your own indices to the values.

If not specified it by default starts from 0 till (n-1), where n is number of elements. 

We can use list,tuple or range function to specify index.

Let's create some series...
"""

# using strings
import pandas as pd
str="abc def ghi"
s=pd.Series(str,index=(1,2,4))  #here a string is considered as a single element only,
                                 #by determining the indices we can specify the number of elements in the series as string
print(s,"\n")

#using lists
import pandas as pd
lst=[1,2,4,6,8]
s=pd.Series(lst,index=range(5,10), dtype=float)
print(s,"\n")

#using tuples
import pandas as pd
tpl=(2,88,99,45)
s=pd.Series(tpl,index=[1,2,3,4])
print(s,"\n")

#using dictionary
import pandas as pd
dct={"A":100,"B":200,"C":300} # here the key of the value is taken as its index in the series
s=pd.Series(dct)
print(s,"\n")

b=pd.Series(dct,index=["C","A",3,"S"])  #in case of dictionary if indices are specified,
print(b)                            #only those values of dict will be included in the series whose indices are specified 
                                    #for other indices NaN is displayed

#using scalar values
import pandas as pd
scal=32
s=pd.Series(scal,index=range(1,6,2))
print(s)

#using ndarray
import pandas as pd
import numpy as np
a=np.arange(1,9)
b=pd.Series(a,index=["A","B","C","D","E","F","G","H"])
print(b,"\n")

import pandas as pd
a=pd.Series(data=[(1,2.5),None,"hola"]) #if different datatypes are used then dtype of series is choosen according to following preference:
print(a)                            #int < float(NaN) < object(str,list,tuple..)
print(a.dtype)                      #all the other datatypes are type casted into the highest preference one

"""**Attributes**"""

import pandas as pd
a=pd.Series([1,2,3,None],index=("a","b","c","d"))
print(a,"\n")

print("Dimension:",a.ndim,"\n") #returns dimension

print("Shape:",a.shape,'\n') #returns a tuple specifying rows and cols

print("No. of elements:",a.size,"\n") #returns no. of elements in the series

print("Data type:",a.dtype,'\n') #returns the data type of the series

print("Size of series in bytes:",a.nbytes,"\n")

print("Indices:",a.index,"\n") #returns the indices of the values

print("Whether empty:",a.empty,"\n") #returns true if series is empty

print("Has Nan values or not:",a.hasnans) #returns true if any of the value is Nan

"""Accessing the values"""

import pandas as pd
import numpy as np
a=np.arange(1,9)
b=pd.Series(a,index=["A","B","C","D","E","F","G","H"])
print(b,"\n")

print(b[1],b["B"],"\n")   #we can access a value by its default index or specified index

print(b[1:5:2],"\n\n",b["B":"F":2],"\n")     #in case of slicing if we use default indices to access values end index is not included
                                             #but if specified indices are strings,end index is included

print(b[[0,3,4]],"\n\n",b[["A","D","E"]],"\n")   #we can also access values by passing a list of particular indices needed

"""Let's change the values...."""

import pandas as pd
import numpy as np
a=np.arange(1,9)
s=pd.Series(a,index=["A","B","C","D","E","F","G","H"])
print(s,"\n")
                                           #s[3]="st" gives error as it does'nt match with datatype of series 

s[0]=15.6   #if value is changed by this method, it should be able to be typecast into the dtype of series
print(s,"\n")

s[1:3:2]="a"   #in the below 2 methods any value can be given the dtype of series will change according to the preffered dtype
print(s,"\n")

s[[4,6]]=4.4,5
print(s)

"""can we also change the indices? idk let's see...."""

import pandas as pd
import numpy as np
a=np.arange(1,11)
s=pd.Series(a,index=("A","B","C","D","E","F","G","H","I","J"))
print(s,"\n")

s.index=("q","w","e","r","t","y","u","i","o","p")   #here we have to change all the indices
print(s,"\n")

s.rename({"q":"A","p":"J"},inplace=True) #rename is used if only particular indices are to be changed
print(s,"\n")

s.rename(lambda x:x+"m",inplace=True)
print(s,"\n")

import pandas as pd
a=[1,2,3,4,5,6,7]
s=pd.Series(a)
print(s,"\n")

print(s.head(),"\n")  #returns first 5 values by default
print(s.head(3),"\n") #we can also specify the number of values we need
print(s.head(-1),"\n") #if -n is passed as the paramteter, it will return all values excluding n values from bottom 

print(s.tail(),"\n")  #returns last 5 values by default
print(s.tail(3),"\n") #we can also specify the number of values we need
print(s.tail(-1),"\n") #if -n is passed as the paramteter, it will return all values excluding n values from top

import pandas as pd
a=[1,2,3,4,5,6,7]
s=pd.Series(a)
print(s,"\n")
print(s+10.1,"\n")                #here operation is performed on all vaues

b=["A","B","C"]
s=pd.Series(b)
print(s,"\n")
print(s+"m")

import pandas as pd
lst=[1,2,4,6,None]
s=pd.Series(lst)
print(s,"\n")
print(s.max(),"\n")
print(s.min(),"\n")
print(s.sum(),"\n")

import pandas as pd
lst=[1,2,4,6,8]
s=pd.Series(lst)
print(s,"\n")
print(s.count())            #returns no. of values excluding NaN

import pandas as pd
s1=pd.Series([1,100,10.1,None],index=[1,2,3,5])
s2=pd.Series([5,1.1,None,6,15.6],index=[1,2,3,4,5])
print(s1+s2,"\n")
print(s1-s2,"\n")              #these operation are performed on elements having same index in both series
print(s1*s2,"\n")              # for unmatching index resut is NaN
print(s1/s2,"\n")              #any operation on NaN gives NaN
print(s1**s2,"\n")

import pandas as pd
a=[1,2,3,4,5,6,7]
s=pd.Series(a)
print(s,"\n")

print(s==2,"\n")
print(s>2,"\n")
print(s<2,"\n")                      #these return True where condition is satisfied and False otherwise
print(s>=2,"\n")
print(s<=2,"\n")
print(s!=2,"\n")

print(s[s==2],"\n")
print(s[s>2],"\n")
print(s[s<2],"\n")
print(s[s>=2],"\n")                   #these return all the values where condition is satisfied
print(s[s<=2],"\n")
print(s[s!=2],"\n")

import pandas as pd
s=pd.Series([1,1.1,None,22.2],index=["A","H","C","Z"])
print(s,"\n")

print(s.sort_index(),"\n")
print(s.sort_index(ascending=False),"\n")       #sorting values or index returns a copy of series with the effect

print(s.sort_values(),"\n")
print(s.sort_values(ascending=False),"\n")   #NaN is always placed at the end